# 도메인 모델 시작

#### 도메인? 

: **소프트웨어로 해결하고자 하는 문제 영역**

> 도메인이라는 게 생각보다 큰 개념이었다. 
>
> 온라인 서점을 만들려고 한다. 이 때, 온라인 서점은 소프트웨어로 해결하고자 하는 영역 (**구현해야 할 대상**), 즉 도메인이 된다. 온라인 서점 안에는 주문, 회원, 혜택, 결제, 리뷰 등의 또 다른 도메인이 있다. 

- 한 도메인은 다시 하위 도메인으로 나눌 수 있다.

- 특정 도메인을 위한 소프트웨어라고 해서 도메인이 제공해야 할 모든 기능을 구현하는 것은 아니다. 

  ex 결제 시스템은 외부 시스템을 사용하기도 한다.

<br/>

### 도메인 모델

: **도메인 자체를 이해하기 위한 개념 모델**

도메인 모델을 사용하면 *여러 사람들이 동일한 모습으로 도메인을 이해하고 도메인 지식을 공유하는 데 도움*이 된다. 이렇게 **도메인을 이해하기 위해 도움이 되는 모델**을 모두 **도메인 모델**이라고 할 수 있다. 도메인 모델은 객체 기반이 될 수도 있고 다이어그램 기반이 될 수도 있다. 도메인을 이해하는 데 도움이 된다면 *표현 방식은 중요하지 않다*.

도메인 모델은 기본적으로 도메인 자체를 이해하기 위한 개념 모델이다. 개념 모델을 이용해서 바로 코드를 작성할 수 있는 것은 아니기에 구현 기술에 맞는 구현 모델이 따로 필요하지만, 구현 모델이 개념 모델을 최대한 따르도록 할 수는 있다. 

> *개념 모델 VS 구현 모델*
>
> 개념 모델은 순수하게 문제를 분석한 결과다. 개념 모델은 DB, 트랜잭션 처리, 성능, 구현 기술과 같은 것들을 고려하고 있지 않다. (= 실제 코드 작성 시 개념 모델을 있는 구대로 사용 불가.) 그래서 개념 모델을 구현 가능한 형태의 모델로 전환하는 과정을 거친다.
>
> 처음부터 완벽한 개념 모델을 만들기보다는 전체 윤곽을 이해하는 데 집중해서 개념 모델을 작성해야 하고 구현 과정에서 개념 모델을 구현 모델로 점진적으로 발전시켜 나가야 한다.

<br/>

### 도메인 모델 패턴

: 아키텍처 상 도메인 계층을 객체지향 기법으로 구현하는 패턴

일반적인 애플리케이션의 아키텍쳐는 네 개의 계층으로 구성된다.

| 계층                            | 설명                                                         |
| ------------------------------- | ------------------------------------------------------------ |
| 표현 (Presentation)             | 사용자의 요청을 처리하고 사용자에게 정보를 보여줌.           |
| 응용 (Application)              | 사용자가 요청한 기능 실행. 도메인 계층을 조합해서 기능 실행. |
| 도메인 (Domain)                 | 도메인 규칙 구현.                                            |
| 인프라스트럭처 (Infrastructure) | DB 등 외부 시스템과의 연동 처리.                             |

앞에서의 도메인 모델이 개념 모델을 의미한다면 여기서의 도메인 모델은 **도메인 계층의 객체 모델**을 말한다. (구현 모델) 

도메인 계층은 도메인의 핵심 규칙을 구현한다. 주문 도메인의 경우 '출고 전에 배송지를 변경할 수 있다'는 규칙을 구현한 코드가 **도메인 계층에 위치**하게 되며 이 도메인 규칙을 객체 지향 기법으로 구현하는 패턴이 도메인 모델 패턴이다. *핵심 규칙을 구현한 코드*는 *도메인 모델*에만 위치하기 때문에 다른 코드에 영향을 덜 주고 변경 내역을 모델에 반영할 수 있게 된다.

> 도메인 모델이라는 용어는 도메인 자체를 표현하는 개념적인 모델을 의미하지만, 도메인 계층을 구현할 때 사용하는 객체 모델을 언급할 때도 사용한다. 

<br/>

### 도메인 모델 도출

도메인 모델을 구성하는 **핵심 구성요소, 규칙, 기능**을 찾는다. 이 과정은 요구사항에서 출발한다.

- 요구사항에서 기능을 찾는다.

  ```java
  public class Order{
      public void cancel(){...}
  }
  ```

  상세한 구현은 못하더라도 Order에 관련 기능을 메서드로 추가할 수 있다.

- 어떤 데이터로 구성되는지 찾는다.

  ```java
  public class OrderLine{
      private int price;
      private int amounts;
      private calculateAmounts(){...}
  }
  ```

- 데이터와의 관계를 찾는다.

  ```java
  public class Order{
      private List<OrderLine> orderLines;
      public void cancel(){...}
  }
  ```

  OrderLine이 하나 이상이어야 하면 Order의 생성자에서 검사를 해주면 된다. 이렇게 하면 '주문 항목 하나 이상'이라는 도메인 규칙을 구현할 수 있다.

> 도메인을 구현할 때 특정 조건이나 상태에 따라 제약이나 규칙이 달리 적용되는 경우가 많다. (ex 등급) 이럴 때는 다른 요구사항을 분석해서 존재할 수 있는 상태를 분석한뒤, 열거 타입으로 상태 정보를 표현할 수 있다.
>
> 만약 a를 하려면 b어야 한다는 제약 규칙이 있다면 a에서는 verifyB라는 메서드를 먼저 실행한다. verifyB에서는 `if(statue != OrderState.PREPARING){ throw new Exception("b여야만 실행 가능") }` 이런 식으로 막아준다.

> 도메인 용어를 찾는데 시간을 아끼지 말자.

<br>

### 엔티티 밸류

도출한 모델은 Entity와 Value로 구분할 수 있다. 앞에서 만든 Order은 엔티티도 존재하고 벨류도 존재한다.

> 도메인 모델에 set method를 사용하는 것을 지향해야 한다. 
>
> chageInfo()와 setInfo()는 확연히 다른 의미라는 것을 기억하자. 습관적으로 set을 작성해 필드값만 변경해 썼던 것 같다. set 메서드를 사용하면 도메인 객체를 생성할 때 완전한 상태가 아닐 수도 있다.
>
> ```java
>Order order = new Order();
> order.setOrderLine(lines); // set 메서드로 필요한 모든 값을 전달해야 함
> 
> Order order = new Order(orderer, lines, shippingInfo); 
> // 도메인 객체가 불완전한 상태로 사용되는 것을 막으려면 생성 시점에 필요한 것들을 전달해 주여아 함
> // 생성자를 호출하는 시점에 필요한 데이터가 올바른지 검사할 수 있음
> ```

> ```java
>public class Order{
>  public Order(Orderer orderer, ...){
>     setOrderer(orderer);
>      ...
> }
>  private void setOrderer(Orderer orderer){
>      if (orderer == null) throw new Exception("no orderer"); // null 검사
>      this.orderer = orderer;
>  }
> }
> ```
> 
>set의 접근 범위가 private 하기때문에 외부에서 데이터를 변경할 목적으로 set을 사용할 수 없다.

<BR>

#### 엔티티

가장 큰 특징은 **식별자**를 갖는다는 것이다. 엔티티의 식별자는 바뀌지 않는다. 엔티티를 구현한 클래스는 식별자를 이용해서 equls() 메서드와 hashCode() 메서드를 구현할 수 있다.

**식별자 생성**은 다양한 방법으로 할 수 있다.

- UUID

  java.util.UUID 클래스를 사용하면 UUID를 생성할 수 있다.

  ```java
  UUID uuid = UUID.randomUUID();
  String strUuid = uuid.toString;
  ```

- 일련번호 (자동 증가 칼럼)

- 값 직접 입력

- 특정 규칙에 따라 생성

#### 밸류

개념적으로 완전한 하나를 표현할 때 사용한다. 파라미터를 받을 때 String name, int age 처럼 두 개의 필드가 한 개의 개념을 표현하기보다는 Person person 처럼 완전한 하나를 표현하는 게 좋다.

밸류 타입이 꼭 두 개 이상의 데이터를 가져야 하는 것은 아니다.

```java
public class OrderLine{
    private int price;
    private int amounts;
    ...
}
public class Money{
    private int value;
    ...
}
```

price와 amounts는 돈을 의미한다. 그래서 돈을 의미하는 Money 타입을 만든다면 코드를 이해하는데 도움이된다. (엔티티 식별자를 위한 밸류 타입을 사용할 수도 있다.) 이렇게 *의미를 명확하게 표현하기 위해 밸류 타입을 사용*하는 경우도 있다. 밸류 타입의 또 다른 좋은 점은 밸류 타입만을 위한 기능을 추가할 수 있다는 것이다.  

```JAVA
public class Money{
    ...
    // 생성자
    public Money add(Money money) {
    	return new Money(this.value+money.value);    
    }
}
```

이렇게 Money 연산을 만든다면 코드는 정수 타입 연산이 아니라 돈계산 이라는 의미가 된다.

```java
public class OrderLine{
    private Money price;
    private Money amounts;
    public OrderLine(Money price){
        this.amounts = calculateAmounts();
    }
    private Money calculateAmounts(){
        return price.multiply();
    }
}
```

밸류 객체의 데이터를 변경할 때는 **새로운 밸류 객체를 생성**하는 방식을 선호한다. 데이터 변경 기능을 제공하지 않는 타입을 불변이라고 표현 하는데, 보다 안전한 코드를 작성할 수 있다. 

엔티티 타입의 두 객체가 같은지 비교할 때 식별자를 사용한다면, 밸류 객체가 같은지 비교할 때는 모든 속성이 같은지 비교해야 한다.

#### 엔티티 식별자와 밸류 타입

엔티티 식별자의 실제 데이터는 String과 같은 문자열로 구성된 경우가 많다. 신용 카드 번호도 16개의 숫자로 구성된 문자열이며, 많은 온라인 서비스에서 회원을 구분할 때 사용하는 이메일 주소도 문자열이다. 

Money가 단순 숫자가 아닌 도메인의 돈을 의미하는 것처럼 식별자는 단순한 문자열이 아니라 도메인에서 특별한 의미를 지니는 경우가 많기 때문에 **식별자를 위한 밸류 타입**을 사용해서 의미가 잘 드러나도록 할 수 있다. Order의 식별자 타입으로 String 대신 OrderNo 밸류타입을 사용하면 타입을 통해 해당 필드가 주문번호라는 것을 직관적으로 알 수 있다. 

<br>

### 도메인 용어

코드를 작성할 때 도메인에서 사용하는 용어는 매우 중요하다. 도메인에서 사용하는 용어를 코드에 반영하지 않으면 그 코드는 개발자에게 코드의 의미를 해석해야 하는 부담을 준다.

```java
public OrderState{
    STEP1, STEP2, STEP3, STEP4
}
public OrderState{
    PAYMENT_WAITING, PREPARING, SHIPPED, DELIVERING
}
// 결제 대기 중, 상품 준비 중, 출고 완료됨, 배송 중의 상태가 있을 때 첫 번째 OrderState는 개발자에게 코드의 의미를 해석해야하는 부담을 준다. 불필요하다.
// 두 번째 OrderState는 코드를 도메인 용어로 해석하는 과정이 없고 의미를 변환하는 과정에서 발생하는 버그도 줄어들게 된다.
```

도메인 용어는 좋은 코드를 만드는 데 매우 중요한 요소임에 틀림없지만 국내 개발자는 이 점에 있어 불리하다. 영어 때문이다. 

도메인에서 사용하는 용어의 의미를 명확하게 전달하는 영어 단어를 찾기 힘든 경우도 있고, 반대로 비슷한 의미의 영어 단어가 많으면 각 단어의 뉘앙스나 미세한 차이를 몰라서 선택하기 어려울 때도 있다. 국내 개발자가 이해하기 쉽게 발음되는 대로 gubun(구분)과 같은 이름을 사용하기도 한다.

알맞은 영어 단어를 찾는 것은 쉽지 않은 일이지만 **시간을 들여 찾는 노력**을 해야한다. 한영사전을 사용해서 적당한 단어를 찾는 노력을 하지 않고 도메인에 어울리지 않는 단어를 사용하면 코드는 도메인과 점점 멀어지게 된다. 그러니, 도메인 용어에 알맞은 단어를 찾는 *시간을 아까워하지 말자*.
