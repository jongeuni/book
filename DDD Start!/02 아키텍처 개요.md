# 아키텍처 개요

- 표현, 응용, 도메인, 인프라스트럭처가 대표적이다. 

**표현 영역**(또는 UI 영역)은 사용자의 요청을 받아 해석해서 응용 영역에 전달하고 응용 영역의 처리 결과를사용자가 이해할 수 있게 변환해서 다시 사용자에게 응답하는 역할을 한다. 스프링 MVC 프레임워크가 표현 영역을 위한 기술에 해당한다.  표현 영역의 사용자는 웹 브라우저를 사용하는 사람일 수도 있고 REST API를 호출하는 외부 시스템일 수도 있다. 표현 역역은 HTTP 요청을 응용 영역이 필요로 하는 형식으로 변환해서 응용 영역에 전달하고, 응용 영역의 응답을 HTTP 응답으로 변환해서 전송한다.

ex 예를 들어 표현 영역은 웹 브라우저가 http 요청 파라미터로 전송한 데이터를 응용 서비스가 요구하는 형식의 객체 타입으로 변환해서 전달하고, 응용 서비스가 리턴한 결과를 json 형식으로 변환해서 http 응답으로 웹 브라우저에 전송한다.

**응용 영역**은 시스템이 사용자에게 제공해야 할 기능을 구현한다. 응용 영역은 로직을 직접 수행하기보다는 도메인 모델에 로직 수행을 위임하고, 기능을 구현하기 위해 도메인 영역의 도메인 모델을 사용한다. 

**도메인 영역**은 도메인 모델을 구현한다. 도메인 모델은 도메인의 핵심 로직을 구현한다.

**인프라스트럭처 영역**은 구현 기술에 대한 것을 다룬다. 이 영역은 RDBMS 연동을 처리하고, SMTP를 이용한 메일 발송 기능 등을 다룬다. 도메인 영역, 응용 영역, 표현 영역은 구현기술을 사용한 코드를 직접 만들지 않는다. 

> 구현 기술이란 이미 만들어져 있는 것들, 그러니까 외부의 것을 말하는 것이다.

<br>

### 계층 구조 아키텍처

표현과 응용 영역은 도메인 영역을 사용하고, 도메인 영역은 인프라스트럭처 영역을 사용한다.

계층구조는 특성상 상위 계층에서 하위 계층으로의 의존만 존재하고 하위 계층은 상위 계층에 의존하지 않는다. 예를 들어, 표현 계층은 응용 계층에 의존하고 응용 계층은 도메인 계층에 의존하지만 인프라스트럭처 계층이 도메인에 의존하지는 않는다.

근데 이는 계층구조를 엄격하게 적용했을 때 얘기고 구현의 편리함을 위해 계층구조를 유연하게 적용하기도 한다. 예를 들어 응용 계층은 도메인 계층에 의존하지만 더 아래계층인 인프라스트럭처 계층에 의존하기도 한다.

이런 계층 구조를 사용하는 것은 직관적으로 이해하기 쉽다. 하지만 표현, 응용, 도메인 계층이 인프라스트럭처 계층에 종속된다. 밑에서 두 가지 문제점을 볼 수 있다.

1. **테스트의 어려움**

   하나의 계층의 기능만을 테스트 하기 어렵다. (밑 코드에서는 응용 계층)

   ```java
   public class DrollsRuleEngine{ // 인프라 스트럭처 영역
       ...
   }
   public class CaluclateDiscountService{
       private DroolsRuleEngine ruleEngine;
       public CalculateDiscountService(){
           ruleEngine = new DroolsRuleEngine();
       }
       public Money calculateDiscount(){
           ruleEngine.evalute("dd",facts);
           ...
       }
   }
   ```

   응용 계층의 기능을 테스트하기 위해선 종속된 인프라스트럭처 영역이 완벽히 동작해야 한다. 그러니까 이 경우, 내가 calculateDiscount라는 메서드를 테스트하고 싶다면DrollsRuleEngine이 완벽하게 동작해야한다 

2. **기능 확장의 어려움**

   종속되어있기 때문에 만약 DrollsRuleEngine이 아닌 다른 것을 사용하려고 한다면 CaluclateDiscountSerivce 코드와 함께 많은 것을 고쳐야 한다. 구현 방식 변경이 어려워진다.

<br>

### DIP 패턴

고수준 모듈이 제대로 동작하려면 저수준 모듈을 사용해야 한다. 그런데 고수준 모듈이 저수준 모듈에 종속되면 앞에서 언급한 두가지 문제가 발생한다.

그렇다면 어떻게 해야할까? **추상화 인터페이스**를 사용해 저수준 모듈이 고수준 모듈에 의존하도록 바꾸면 된다.

*고수준 모듈 입장에서는 DrollsRuleEngine을 쓰던, 다른 저수준 모듈을 쓰던 상관 없다*. 단지 저수준 모듈로 얻고자 했던 기능이 잘 돌아가는 것만이 중요할 뿐이다. 저수준 모듈을 인터페이스로 추상화 하면

```java
public interface RuleDisconter{
    public Money applyRules(Customer customer, List<OrderLine> orderLines);
}
public class CalculateDiscountService{
    private RuleDiscounter ruleDiscounter;
    public CalculateDiscountService(RuleDiscounter ruleDiscounter){
        this.ruleDiscounter = ruleDiscounter;
    }
    ...
}
```

구현 클래스는 물론 이 인터페이스를 상속받아서 구현한다. 

이렇게 되면 고수준 모듈은 더이상 저수준 모듈에 의존하지않는다. 추상화한 인터페이스에 의존할 뿐이다. 실제 사용할 저수준 구현 객체는 다음 코드처럼 의존 주입을 통해 전달받을 수 있다.

```JAVA
RuleDisconter ruleDiscounter = new DroolsRuleDiscounter(); // 저수준 객체 생성
CalculateDiscountService disService = new CalculateDiscountService(ruleDiscounter);
```

이렇게 되면 위에서 말한 두가지 문제가 해결된다. 

1. CalculateDiscountSerivce가 제대로 동작하는지 테스트하려면 RuleDisconter을 구현한 객체가 필요하다. RuleDisconter은 인터페이스이므로 **대용 객체를 사용해 테스트를 진행할 수 있다.** 실제 구현 클래스가 없어도 된다는 뜻이다. 저수준 모듈에 직접 의존했다면 저수준 모듈이 만들어지기 전까지 테스트를 할 수가 없다.

2.  구현 기술을 변경하더라도 고수준 모델을 수정할 필요가 없다. 그냥 저수준 객체 생성 부분만 변경해주면 된다.  

> DIP를 단순히 인터페이스와 구현 클래스를 분리하는 정도로 받아들일 수 있다. DIP는 고소준 모듈이 저수준 모듈에 의존하지 않도록 하기 위함이다.

- DIP와 아키텍처

인프라스트럭처 영역은 구현 기술을 다루는 저수준 모듈이고 응용 영역과 도메인 영역은 고수준 모듈이다. 원래는 응용 영역, 도메인 영역에서 인프라스트럭처 영역을 사용하므로써 의존한다. DIP를 적용하면 인프라스트럭처 영역이 응용 영역과 도메인 영역에 의존(상속)하는 구조가 된다. **인프라스트럭처에 위치한 클래스가 도메인이나 응용 영역에 정의한 인터페이스를 상속받아 구현**하는 구조가 되므로 *도메인과 응용 영역에 대한 영향을 주지 않거나 최소화*하면서 구현 기술을 변경하는 것이 가능하다.

![DIP를 적용한 구조](https://user-images.githubusercontent.com/66874658/141793509-bca02f20-01f3-4048-912c-e60f5ab47a25.png)

[위 그림](https://songii00.github.io/2020/07/13/2020-07-13-DDDStart!_Item_2/)이 예시가 된다. MyBatis 대신 JPA를 구현 기술로 사용하고 싶다면 JPA를 이용한 OrderRepository 구현 클래스를 인프라스트럭처 영역에 추가하면 된다.

<br>

## 도메인 영역의 주요 구성요소

도메인 영역은 도메인의 핵심 모델을 구현한다. 도메인 구성 요소는 밑 표와 같다. 

| 요소                         | 설명                                                         |
| ---------------------------- | ------------------------------------------------------------ |
| 엔티티 Entity                | 고유의 식별자를 갖는 객체로 도메인의 고유한 개념을 표현한다. |
| 밸류 Value                   | 고유의 식별자를 갖지 않는 객체로  도메인 객체의 속성을 표현할 때 사용된다. 구매 금액을 위한 money와 같은 타입이 밸류 타입이다. |
| 애그리거트 Aggregate         | 관련된 엔티티와 밸류 객체를 개념적으로 하나로 묶은 것이다. 예를 들어 Order 엔티티와 OrderLine 밸류, Order 밸류 객체를 '주문' 애그리거트로 묶을 수 있다. |
| 리포지터리 Repository        | 도메인 모델의 영속성을 처리한다. 예를 들어 DBMS 테이블에서 엔티티 객체를 로딩하거나 저장하는 기능을 제공한다. |
| 도메인 서비스 Domain service | 특정 엔티티에 속하지 않은 도메인 로직을 제공한다. 다양한 조건을 이용해서 구현하게 되어 여러 엔티티와 밸류를 필요할 경우 도메인 서비스에서 로직을 구현한다. |

```
|-- order
	|-- domain
		|-- Order(Aggregate, Root-Entity)
		|-- OrderLine(Entity)
		|-- Orderer(Entity)
		|-- OrderRepository(Repository)
		|-- Address(Value)
```

응용 영역의 서비스가 응용 로직을 다룬다면, 도메인 서비스는 도메인 로직을 다룬다. 도메인 서비스는 상태 없이 로직만 구현한다. 

<br>

### 엔티티와 밸류

DB 테이블의 엔티티와 도메인 모델의 엔티티를 구분하지 못하는 경우가 있다. 

두 모델의 가장 큰 차이점은 **도메인 모델의 엔티티**는 데이터와 함께 **도메인 기능을 함께 제공**한다는 점이다. 예를 들어, 주문을 표현하는 엔티티는 주문과 관련된 데이터뿐만 아니라 주소 변경을 위한 기능도 함께 제공한다. *도메인 모델의 엔티티*는 단순히 데이터를 담고 있는 데이터 구조라기보다는 *데이터와 함께 기능을 제공하는 객체*이다. 

또 다른 차이점은 도메인 모델의 엔티티는 도메인을 보다 잘 이해할 수 있도록 하기 위해 두 개 이상의 데이터가 개념적으로 하나인 경우 밸류 타입을 이용해 표현할 수 있다는 것이다. 그러나 관계형 데이터베이스는 밸류 타입을 표현하기 힘들다.

밸류는 불변으로 구현하는 것을 권장한다. 이는 엔티티의 밸류 타입 데이터를 변경할 때 객체 자체를 완전히 교체한다는 것을 의미한다. 

```java
public class Order{
    private ShippingInfo shippingInfo; 
    ...
    public void changeShippingInfo(ShippingInfo newShippingInfo){
    	setShippingInfo(newShippingInfo); // 새로운 객체를 필드에 할당
    }
}
```

<br>

### 애그리거트

도메인 모델이 복잡해지면 개발자가 전체 구조가 아닌 한 개 엔티티와 밸류에만 집중하게 되는 경우가 발생한다. 이렇게 개별 요소에만 초점을 맞추다보면 큰 수준에서 모델을 이해하지 못하는 문제가 발생한다. 

**애그리거트는 관련 객체를 하나로 묶은 군집**이다.  예를 들어 주문, 배송지 정보, 주문자, 주문 목록의 하위 모델을 하나로 묶어서 주문이라는 상위 개념으로 표현할 수 있다. 이렇게 관련한 객체를 애그리거트로 묶으면 전체 구조를 이해하는 데 도움이 되고, 복잡한 도메인 모델을 관리하는데 좋다.

애그리거트는 군집에 속한 객체들을 관리하는 루트 엔티티를 갖는다. **루트 엔티티는 애그리거트에 속해있는 엔티티와 밸류 객체를 이용해서 애그리거트가 구현해야할 기능을 제공**한다. *애그리거트를 사용하는 코드는 애그리거트 루트가 제공하는 기능을 실행*하고 *애그리거트 루트를 통해서 애그리거트 내의 다른 엔티티나 밸류 객체에 접근*하게 된다. 

<br>

### 리포지터리

도메인 객체를 지속적으로 사용하려면 저장소에 도메인 객체를 보관해야 한다. 이를 위한 도메인 모델이 리포지터리이다. 리포지터리는 애그리거트 단위로 도메인 객체를 저장하고 조회하는 기능을 정의한다. 도메인 모델을 사용해야하는 코드는 리포지토리를 통해 도메인 객체를 구한뒤 도메인 객체의 기능을 실행하게 된다. 

리포지터리 **인터페이스는 도메인 영역**에 속하며, 실제 구현 클래스는 인프라스트럭처 영역에 속한다.

응용 서비스와 리포지터리는 밀접한 연관이 있다.

- 응용 서비스는 필요한 도메인 객체를 구하거나 저장할 때 리포지터리를 사용한다.
- 응용 서비스는 트랜잭션을 관리하는데, 트랜잭션 처리는 리포지터리 구현 기술에 영향을 받는다.

<br>

### 요청 처리 흐름

사용자가 애플리케이션에 기능 실행을 요청하면 그 요청을 처음 받는 영역은 **표현 영역**이다. 컨트롤러가 사용자의 요청을 받아 처리하게 된다.

표현 영역은 사용자가 전송한 데이터 형식이 올바른지 검사하고 문제가 없다면 데이터를 이용해서 응용 서비스에 기능 실행을 위임한다. 이 때 응용 서비스가 요구하는 형식으로 변환해서 데이터를 전달한다. 

**응용 서비스**는 도메인 모델을 이용해서 기능을 구현한다. 기능 구현에 필요한 도메인 객체를 리포지터리에서 가져와 실행하거나 신규 도메인 객체를 생성해서 **리포지터리에 저장**한다.

<br>

### 인프라스트럭처 개요

인프라스트럭처는 표현, 응용, 도메인 영역을 지원한다. DIP에서 언급한 것처럼 도메인 영역과 응용 영역에서 인프라스트럭처의 기능을 직접 사용하는 것보다 이 두 영역에 정의한 인터페이스를 인프라스트럭처 영역에서 구현하는 것이 시스템을 더 유연하고 테스트하기 쉽게 만든다. 

하지만 무조건 인프라스트럭처에 대한 의존을 없애는 게 좋은 것은 아니다. 좋은 예가 @Transactional 애노테이션이다. @Transactional을 사용하면 한 줄로 트랜잭션을 처리할 수 있는데 코드에서 스프링에 대한 의존성을 없애려면 복잡한 스프링 설정을 사용해야 한다. 의존은 없앴지만 설정만 복잡해지고 개발시간만 늘어난다. 영속성 처리를 위해 @Entity나 @Table같은 JPA 전영 애노테이션을 도메인 모델 클래스에 사용하는 것도 마찬가지다.

구현의 편리함은 DIP가 주는 다른 장점(변경의 유연함, 테스트가 쉬움) 만큼 중요하기때문에 DIP의 장점을 해치지 않는 범위에서 응용 영역과 도메인 영역에서 구현 기술에 대한 의존을 가져가는 것이 현명하다. 응용 영역과 도메인 영역이 인프라스트럭처에 대한 의존을 완전히 갖지 않도록 시도하는 것은 자칫 구현을 더 복잡하고 어렵게 만들 수 있다.

표현 영역은 항상 인프라스트럭처영역과 짝궁을 이룬다. 스프링 MVC를 사용하여 웹요청을 처리하면 스프링이 제공하는 MVC 프레임워크에 맞게 표현 영역을 구현해야 하고, REST API 서버를 구축하면 그에 맞게 웹 요청 처리 부분을 구현해야한다. (인프라스트럭처에서 사용하는 기술 사용)

<BR>

### 모듈 구성

domain 모듈은 도메인에 속한 애그리거트를 기준으로 다시 패키지를 구성한다.

![도메인이 크면 하위 도메인별로 모듈을 나눈다](https://user-images.githubusercontent.com/66874658/141798670-4007863f-eb13-4ab9-8b83-3798a6f90bee.png)

각 애그리거트의 모델과 리포지터리는 같은 패키지에 위치시킨다, 얘를들어, 주문과 관련된 Order, OrderLine, Orderer, OrderRepository 등은 com.myshop.order.domain 패키지에 위치시킨다.

도메인이 복잡하면 도메인 모델과 도메인 서비스를 다음과 같이 별도 패키지에 위치시킬수도 있다.

com.myshop.order.domain.order: 애그리거트 위치

com.myshop.order.domain.service: 도메인 서비스 위치

도메인 별로 패키지를 구분할 수도 있다. com.myshop.catalog.application.product

모듈 구조를 얼마나 세분화해야 하는지에 대해 정해진 규칙은 없다. 한 패키지에 너무 많은 타입이 몰려서 코드를 찾을 때 불편한 정도만 아니면 된다. 한 패키지에 가능하면 10개 미만으로 타입 개수를 유지하려고 노력해라. 이개수가 넘어가면 모듈을 분리하려는 시도를 하자.

