# 애그리거트

도메인 객체 모델이 복잡해지면 개별 구성 요소 위주로 모델을 이해하게 되고 전반적인 구조나 큰 수준에서 도메인 간의 관계를 파악하기 어려워진다.

1. 상위 수준에서 모델이 어떻게 엮여 있는지 알아야 전체 모델을 망가뜨리지 않으면서 요구사항을 반영할 수 있다.
2. 세부적인 모델만 이해한 상태면 코드 수정이 두려워서 코드 변경을 최대한 회피하는 쪽으로 간다.
3. 이는 장기적 관점에서 더 힘들어진다.

그렇다면 상위 수준에서 모델을 바라볼 수 있는 방법이 필요한데, 그게 바로 **애그리거트**이다.  애그리거트는 관련된 객체를 하나의 군으로 묶어준다. 

애그리거트는 모델을 이해하는 데 도움을 줄 뿐만 아니라 일관성을 관리하는 기준이 된다. 모델을 보다 잘 이해할 수 있고 애그리거트 단위로 일관성을 관리하기 때문에 애그리거트는 복잡한 도메인을 단순한 구조로 만들어준다. 복잡도가 낮아지는 만큼 도메인 기능을 확장하고 변경하는 데 필요한 노력도 줄어든다.

애그리거트는 관련된 모델을 하나로 모은 것이기 때문에 한 애그리거트에 속한 객체는 유사하거나 동일한 라이프사이클을 갖는다. 주문 애그리거트를 만들기 위해선 Order, OrderLine, Orderer와 같은 관련 객체를 함께 생성해야 한다. 도메인 규칙에 따라 일부 객체를 만들 필요가 없는 경우도 있지만 애그리거트에 속한 구성 요소는 대부분 함께 생성하고 함께 제거한다.

<br>

애그리거트는 경계를 갖는다. 한 애그리거트에 속한 객체는 다른 애그리거트에 속하지 않는다. 한 애그리거트는 자신을 관리할 뿐, 다른 애그리거트는 관리하지 않는다. (주문 애그리거트에서 회원의 비밀번호를 변경하거나 상품의 가격을 변경하지 않는다.) 경계를 설정할 때 기본이 되는 것은 도메인 규칙과 요구사항이다.  도메인 규칙에 따라 **함께 생성되는 구성 요소는 한 애그리거트에 속할 가능성이 높다**. 또 **함께 변경되는 빈도가 높은 객체도 한 애그리거트에 속할 가능성이 높다**. (OrderLine의 주문 상품 개수를 변경하면 도메인 규칙에 따라 Order의 총 주문 금액을 새로 계산해야 한다.)

'A가 B를 갖는다.'의 요구 사항일 경우 반드시 한 애그리거트에 속한다는 것을 의미하는 것은 아니다. 상품 페이지에 들어가면 상품 정보와 리뷰 내용을 보여줘야 한다는 요구사항이 있지만 상품은 리뷰와 함께 생성되지 않고 함께 변경되지도 않는다. 게다가 생성과 변경의 주체도 다르다. (상품 담당자, 고객) 상품의 변경이 리뷰에 영향을 주지 않고 리뷰의 변경이 상품에 영향을 주지도 않기 때문에 이 둘은 다른 애그리거트에 속한다. 

처음 도메인 모델을 만들기 시작하면 큰 애그리거트로 보이는 것들이 많지만 도메인에 대한 경험이 생기고 도메인 규칙을 제대로 이해할수록 실제 애그리거트의 크기는 줄어들게 된다. 

<br>

### 애그리거트 루트

애그리거트는 여러 객체로 구성되기 때문에 한 객체만 상태가 정상이어서는 안 된다. 도메인 규칙을 지키려면 애그리거트에 속한 모든 객체가 정상 상태를 가져야 한다. a가 변경 됐을 때 b도 변경 되어야 한다면 b도 변경해야 일관된 상태를유지할 수 있다. 일관된 상태를 유지하려면 애그리거트 전체를 관리할 주체가 필요한데 이 책임을 지는 것이 애그리거트 루트 엔티티이다. 

애그리거트 루트 엔티티는 애그리거트의 대표 엔티티로 애그리거트에 속한 객체는 **애그리거트 루트 엔티티에 직접 또는 간접적으로 속한다**.

애그리거트 루트가 애그리거트에 속한 객체를 포함하는 것으로 끝나는 것은 아니다. 애그리거트 루트의 핵심 역할은 애그리거트의 일관성이 깨지지 않도록 하는 것이다. 이를 위해 애그리거트 루트는 애그리거트가 제공해야 할 도메인 기능을 구현한다. 예를 들어 주문 애그리거트는 배송지 변경, 상품 변경과 같은 기능을 제공하는데 애그리거트 루트인 Order가 이 기능을 구현한 메서드를 제공한다.

#### 도메인 규칙과 일관성

애그리거트 루트는 도메인 규칙에 따라 애그리거트에 속한 객체의 일관성이 깨지지 않도록 구현해야 한다. 배송이 시작되기 전까지만 배송지 정보를 변경할 수 있는 규칙이 있다면 애그리거트 루트의 메서드는 배송시작 여부를 확인한 후에 배송지 번호를 변경해야 한다.

애그리거트 루트가 아닌 다른 객체가 애그리거트에 속한 객체를 직접 변경하면 안된다. 이는 애그리거트 메서드에서 구현된 도메인 규칙을 적용할 수 없어 모델의 일관성을 깨는 원인이 된다. 일관성을 지키기 위해 상태 확인 로직을 다른 객체의 메서드에도 적용할 수 있지만 이렇게 되면 코드가 중복되는 상황이 생긴다. 

> ```java
> ShippingInfo si = order.getShippingInfo();
> si.setAddress(newAddress);
> ```
>
> 이런식으로 변경한다면 업무 규칙 (배송 시작 전에만 배송지 정보를 변경할 수 있다.)을 무시하므로 데이터 일관성을 깨지게 만든다. **set 메서드의 위험성이 여기에 있다**. ⚠⚠

불필요한 중복을 피하고 애그리거트 루트를 통해서만 도메인 로직을 구현하게 하려면 다음의 두가지를 지켜야 한다.

* 단순히 필드를 변경하는 set 메서드를 public 범위로 만들지 않는다.
* 밸류 타입은 불변으로 구현한다.

보통 공개 set 메서드는 필드에 값을 할당하는 것으로 끝나는 경우가 많다. 잘해야 null을 검사하는 정도이다. 공개 set 메서드는 도메인 로직이 메인 객체가 아닌 응용 영역이나 표현 영역으로 분산되기 만드는 원인이 되고, 이름으로 의미나 의도를 파악하기 어렵다. 

도메인 모델의 엔티티나 밸류에 공개 set 메서드만 넣지 않아도 일관성이 깨질 가능성이 줄어들고, 의미가 잘 드러나는 메서드를 사용해 구현할 가능성은 높아진다 (cancel(), changePw())

밸류는 불변타입으로 구현한다. 이렇게 한다면 밸류 객체의 값을 변경하는 방법은 새로운 밸류 객체를 할당하는 것뿐이다. 애그리거트 루트가 제공하는 메서드에 새로운 밸류 객체를 전달해서 값을 변경하는 방법밖에는 없다.

```java
public void changeShippingInfo(ShippingInfo newShippingInfo){
    verifyNotYetShipped();
    setShippingInfo(newShippingInfo)
}
```

밸류타입의 내부 상태를 변경하려면 애그리거트 루트를 통해서만 가능하다. 그래서 **애그리거트 루트가 도메인 규칙을 올바르게만 구현하면 애그리거트 전체의 일관성을 올바르게 유지**할 수 있다.

#### 애그리거트 루트의 기능 구현

애그리거트 루트는 애그리거트 내부의 다른 객체를 조합해서 기능을 완성한다. 예시로 memeber 애그리거트 루트는 암호 변경을 위해 pw 객체에 암호 일치 여부를 확인한다. 애그리거트 루트가 구성요소의 상태만 참조하는 것은아니다. 기능 실행을 위임하기도 한다. 

```java
public class Order{
    private OrderLines orderLines;
    public void changeOrderLines(List<OrderLine> newLines){
        orderLInes.changeOrderLines(newLines); // 내부의 필드에 상태 변경 위임
        this.totalAmounts = orderLines.getTotalAmounts();
    }
}
```

만약 Order가 getOrderLines()를 제공한다면 changeOrderLines()는 어디에서든 호출할 수 있으므로 (changeOrderLines()가 orderLines에 있기 때문) totalAmounts가 일치하지 않게 된다. 이런 버그가 생기지 않도록 애초에 OrderLine 목록을 변경할 수 없도록 **불변으로 구현**한다. 만약 불변으로 구현할 수 없다면 *protected 범위로 한정*해서 외부에서 실행할 수 없도록 제한하는 방법이 있다. (보통 한 애그리거트에 속하는 모델은 한 패키지에 속하기 때문에 외부에서 상태 변경 기능을 실행하는 것을 방지할 수 있다.)

#### 트랜잭션 범위

트랜잭션 범위는 작을수록 좋다. 테이블을 기준으로 **한 트랜잭션이 한 개 테이블을 수정하는 것과 세 개 테이블을 수정하는 것은 성능에서 차이가 발생**한다.

**한 트랜잭션에서는 한 개의 애그리거트만 수정해야 한다**. *한 트랜잭션에서 한 애그리거트만 수정한다는 것*은 **애그리거트에서 다른 애그리거트를 변경하지 않는다**는것을 말한다. 

한 트랜잭션에서 두 개 이상의 애그리거트를 수정하면 트랜잭션 충돌이 발생할 가능성이 높아진다.  이는 **애그리거트가 자신의 책임 범위를 넘어 다른 애그리거트의 상태까지 관리하는 꼴**이다. 애그리거트는 서로 최대한 독립적이어야 하는데 **한 애그리거트가 다른 애그리거트의 기능에 의존하기 시작하면 애그리거트 간 결합도가 높아지게 된다**. (애그리거트의 수정을 더 어렵게 만듦) 결합도가 높아지면 높아질수록 향후 수정비용이 증가하므로 만약 그래야 할 경우 애그리거트를 직접 수정하지 말고 **응용 서비스에서 두 애그리거트를 수정하도록 구현**해야한다.

<br>

### 리포지터리와 애그리거트

리포지터리는 애그리거트 단위로 존재한다. 각각 별도의 DB 테이블에 저장한다고 해서 리포지터리를  각각 만들지는 않는다.

EX ) Order과 OrderLine을 물리적으로 각각 별도의 DB 테이블에 저장한다고 해서 Order과 OrderLine을 위한 리포지터리를 각각 만들지 않는다. Order가 애그리거트 루트이고 OrderLine인 애그리거트에 속하는 구성요소이므로 Order을 위한 리포지터리만 존재한다.

어떤 기술을 이용해서 리포지터리를 구현하느냐에 따라 애그리거트의 구현도 영향을 받는다. 

애그리거트는 개념적으로 하나이므로 리포지터리는 애그리거트 전체를 저장소에 영속화 해야 한다. 예를들어 Order 애그리거트와 관련된 테이블이 세 개라면 리포지터리를 통해서 Order *애그리거트를 저장할 때* 애그리거트 루트와 매핑되는 테이블 뿐만 아니라 **애그리거트에 속한 모든 구성요소를 위한 테이블에 데이터를 저장해야한다**.

리포지터리가 완전한 애그리거트를 제공하지않으면 NPE와 같은 문제가 발생하다.

<BR>

### ID를 이용한 애그리거트 참조 

한 객체가 다른 객체를 참조하는 것처럼 애그리거트도 다른 애그리거트를 참조한다. 애그리거트의 관리 주체가 애그리거트 루트이므로 *애그리거트에서 다른 애그리거트를 참조한다는 것은 애그리거트 루트를 참조한다는 것과 같다*.

애그리거트간의 참조는 필드를 통해 구현할 수 있다. 예를 들어, 주문 애그리거트에 속해있는 Order은 주문한 회원을 참조기 위해 회원 애그리거트 루트인 Member을 필드로 참조할 수 있다. 필드를 이용해 애그리거트를 직접 참조하면 다른 애그리거트의 데이터를 객체 탐색을 통해 조회할 수 있기에 개발자에게 구현 편리함을 제공한다. 

하지만 이런 필드를 이용한 애그리거트 참조는 여러 문제가 있기도 하다.

1) 가장 큰 문제는 편리함을 오용할 수 있다는 것이다. *한 애그리거트 내부에서 다른 애그리거트 객체에 접근할 수  있으면 다른 애그리거트의 상태를 쉽게 변경할 수 있게 된다*. 트랜잭션 범위에서 언급한 것처럼 **한 애그리거트가 관리하는 범위는 자기 자신으로 한정해야 한다**. 그런데 애그리거트 내부에서 다른 애그리거트 객체에 접근할 수 있으면 구현의 편리함때문에 다른 애그리거트를 수정하고자하는 유혹에 빠지기 쉽다. 

2) 두 번째 문제는 애그리거트를 직접 참조하면 성능과 관련된 여러가지 **고민**을 해야 한다는 것이다. JPA를 사용할 경우 참조한 객체를 **지연 로딩**과 **즉시 로딩** 두 가지 방식으로 로딩할 수 있다. 두 로딩 방식 중 무엇을 사용할지 여부는 애그리거트의 어떤 기능을 사용하느냐에 따라 달라진다. 단순히 연관된 객체의 데이터를 함께 화면에 보여주어야 하면 즉시 로딩이 조회 성능에 유리하지만, 애그리거트의 상태를 변경하는 기능을 실행하는 경우에는 불 필요한 객체를 함게 로딩할 필요가 없으므로 지연 로딩이 유리하다. 

3) 세 번째 문제는 확장이다. 사용자가 늘고 트래픽이 증가하면 자연스럽게 부하를 분산하기 위해 하위 도메인마다 서로 다른 DBMS를 사용할 가능성이 높아진다. 심지어 하위 도메인마다 다른 종류의 데이터 저장소를 사용하기도 한다. 한 하위 도메인은 마리아 DB를 사용하고 다른 하위 도메인은 몽고 DB를 사용하는 식으로 말이다. 이는 더이상 다른 애그리거트 루트를 참조하기 위해 JPA와 같은 단일 기술을 사용할 수 없음을 의미한다.

이런 세 가지 문제를 완화할 때 사용할 수 있는 것이 **ID를 이용해서 다른 애그리거트를 참조**하는 것이다.

1. ID 참조를 사용하면 모든 객체가 참조로 연결되지 않고 한 애그리거트에 속한 객체만 참조로 연결된다. 

   User.getEntityOne().getEntityTow() X 

   이는 애그리거트의 경계를 명확히 하고 모델의 **복잡도를 낮춰준다**. 또한 애그리거트간의 의존을 제거하므로 응집도를 높여주는 효과도 있다. 참조하는 애그리거트가 필요하면 응용 서비스에서 아이디를 이용해서 로딩하면 된다.

2. ID를 참조를 사용하면 **한 애그리거트에서 다른 애그리거트를 수정하는 문제를 원천적으로 방지**할 수 있다. 

   *외부 애그리거트를 직접 참조하지 않기 때문에* 애초에 한 애그리거트에서 다른 애그리거트의 상태를 변경할 수 없다.

3. 애그리거트별로 다른 구현 기술을 사용하는 게 가능해진다.

   중요 데이터는 RDBMS에 저장하고 조회 성능이 중요한 데이터는 NOSQL에 저장할 수 있다. *아이디로 애그리거트를 참조하면 리포지터리마다 다른 저장소를 사용할 수도 있다*.

#### id를 이용한 참조와 조회 성능

아이디 참조방식을 사용하면 N+1 조회 문제가 나타난다. ID 참조 방식을 사용하면서 N+1 조회 문제가 발생하지 않도록 하려면 조회 쿼리를 사용하면 된다.

> n+1조회문제는?
>
> 조회 대상이 n개일 때 n개를 읽어오는 한 번의 쿼리와 연관된 데이터를 읽어오는 쿼리를 n번 실행하는 것이다. 지연 로딩 시에도 발생한다.

<BR>

### 애그리거트 간 집합 연관

카테고리에 한 개 이상의 상품이 속할 수 있으니 카테고리와 상품은 1:N관계이고, 한 상품이 한 카테고리에만 속할 수 있다면 상품과 카테고리 관계는 n:1 관계이다.

애그리거트간 1:n관계는 Set과 같은 컬렉션을 이용해서 표현할 수 있다.

```java
public class Category{
    private Set<Product> products; // 다른 애그리거트에 대한 1:n 연관
    ...
}
```

> 개념적으로 존재하는 애그리거트간의 1:n 연관을 실제 구현에 반영하는 것이 요구사항을 충족하는 것과는 상관 없는 경우가 종종 있다. 특정 카테고리에 있는 상품 목록을 보여주는 요구사항을 생각해보자.
>
> 카테고리에 있는 상품 목록을 보여주는 요구사항을 생각해보면 보통 목록 관련 요구사항은 페이징을 이용해서 제품을 나눠서 보여준다. 이 기능을 카테고리 입장에서 1:n 연관을 이용해서 구현하면 다음과 같은 방식으로 코드를 작성해야 한다.
>
> ```java
> public class Category{
>  	private Set<Product> products;
>  	public List<Product> getProducts(int page, int size){
>      		List<Product> sortedProducts = sortById(prodcuts); // 모든 상품 찾아오기
>      	return sortedProducts.subList((page-1)*siz, page*size);
>  	}
> }
> ```
>
> Category에 있는 모든 상품을 찾아온 후, 페이징 한다. 이렇게 하면 다음 페이지를 찾아올 때마다 모든 상품을 조회하게 되는데. 실행 속도가 매우 느려질 것이다. 

카테고리에 속한 상품을 구할 필요가 있다면 상품 입장에서 자신이 속한 카테고리를 n:1으로 연관지어 구하면 된다.

```java
public class Product{
    private CategoryId category;
}
```

 ```java
 public class ProductListService{
     public Page<Product> getProductCategory(Long categoryId, int page, int size){
         Category category = categoryRepository.findById(categoryId); // 상품의 카테고리 찾기
         List<Product> products = productRepository.findById(category.getId(), page, size); // 상품 찾기
         int totalCount = productRepository.countByCategoryId(categor.getId()); // 총 상품 수
         return new Page(page, size, totalCount, products);
     }
 }
 ```

Category에 있는 상품 List를 이용해 찾아오는 게 아니라, 상품에서 특정 카테고리에 속한 상품 목록을 찾아온다.

<br>

m:n 구현도 마찬가지다. 개념적으로는 양방향 m:n이 존재하지만 실제 구현에서는 단방향 m:n연관만 적용하면 될 때가 있다.

> 카테고리별 제품을 보는데 제품은 한번에 읽지 않고 Paging을 사용에 읽어온다. 그리고 제품이 속한 모든 카테고리가 상품 상세화면에서 필요하다. 이 요구사항을 고려할 때 상품에서 카테고리로의 집합 연관만 존재하면 된다. 즉, 개념적으로는 상품과 카테고리의 양방향 m:n연관이 존재하지만 실제 구현에서는 상품에서 카테고리로의 단방향 m:n 연관만 적용하면 되는 것이다. 

```java
@Entity
@Table(name="product")
public class Product {
    ...
    @ElementCollection
    @CollectionTable(name = "product_category",
                    joinColumns = @JoinColumn(name = "product_id"))
    private Set<CategoryId> categoryIds;
 }
```

> 컬렉션 매핑을 사용하면 Id참조를 이용한 m:n 단방향 연관을 구현할 수 있고,  JPQL의 member of 연산자를 이용해 카테고리에 속한 상품 목록을 구할 수 있다고 한다. 이는 내가 사용해보지 않아서 잘 모르겠다.

<br>

### 애그리거트를 팩토리로 사용하기

온라인 쇼핑몰에서 고객이 여러 차례 신고를 해서 특정 상점이 더이상 물건을 등록하지 못하도록 차단 당한 상태라고 해보자. 상품 등록 기능을 구현한 응용 서비스는 상점이 차단 상태가 아닌 경우에만 상품을 생성하도록 구현할 수 있을 것이다. 

```JAVA
public class RegisterProductService{
    public ProductId registerNewProduct(NewProductRequest req){
        // 온라인 쇼핑몰이 차단됐는지 확인 후 차단 됐으면 예외 발생
        // 아니라면 상품 생성
    }
}
```

코드가 나빠 보이지는 않지만 중요한 도메인 로직 처리가 응용 서비스에 노출되었다. *상점이 상품을 생성할 수 있는지 여부를 판단하고 상품을 생성하는 것*은 논리적으로 하나의 도메인 기능인데 응용 서비스에서 구현하고 있는 것이다.

이 도메인 기능을 넣기 위해 별도의 도메인 서비스나 팩토리 클래스를 만들 수 있지만 이 기능을 구현하기 더 좋은 장소는 Store 애그리거트이다. Product 생성 기능을 Store 애그리거트에 옮겨보자.

```java
public class Store extends Member{
    public Product createProduct(ProductId newProductId,...){
        // 만약 블록되어있으면 예외
        return new Product(newProductId, geId(),...)
    }
}
```



